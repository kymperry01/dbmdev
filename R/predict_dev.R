#' Predict temperature-dependent development rates of diamondback moth
#' @description
#' This is the main modelling function in the \code{dbmdev}
#' package. It predicts temperature-dependent development rates of diamondback
#' moth life stages at hourly time steps at a single geographic location. Predictions
#' can be forward or back in time beginning from user-specified biofix (time
#' point and developmental stage).
#'
#' @param df A \code{data.frame} of hourly temperature observations with
#' three variables named "datetime" (POSIX), "obs" (numeric
#' temperature observations in degrees Celsius), and "location_key" (a
#' character code that uniquely identifies a location, either provided by the
#' user or arbitrarily by the \code{\link{hourly}} function.
#' Hourly temperatures can be interpolated from daily maximum minimum
#' temperatures using \code{\link{hourly}}.
#'
#' @param FUN The name of the function used to model temperature-dependent
#' development responses (character or unquoted function name).
#' Only model "briere2" is implemented currently.
#'
#' @param params A \code{matrix} containing the developmental
#' parameters of the briere2 model for individual stages of diamondback moth.
#' Fitted parameters for diamondback moth are generated by default
#' by a call to \code{\link{dev_params}}.
#' The four parameters are:
#' \emph{a}, a constant from the model;
#' \emph{Tmin}, the minimum threshold temperature for development in degrees Celsius;
#' \emph{Tmax}, the maximum threshold temperature for development in degrees Celsius;
#' \emph{m}, the power coefficient.
#' Named matrix rows hold the parameters for each life stage.
#'
#' @param start_date The starting date for development in
#' YYYY-MM-DD format (character)
#'
#' @param start_hour The starting hour for development from 1-23
#' (numeric). The default value is 12 (midday).
#'
#' @param start_stage The starting life stage for development (character).
#' Must be a life stage for which parameters exist in the \code{params} object
#' Run \code{row.names(devparams())} to see possible values.
#'
#' @param start_dev The proportion (numeric) of stage development from which to commence
#' development predictions, ranging from 0 (no development) to 1
#' (development complete). The default value of 0.5 is the
#' mid-point of stage development. To predict the full
#' development period of the starting life stage, set start_dev to 0 if
#' modelling forward in time or to 1 if modelling back in time.
#'
#' @param gens The number of complete generations to predict (numeric). This
#' number is limited by the length of the temperature data time series.
#'
#' @param direction The direction in time, either "forward" or "back"
#' (character). The default value is "forward".
#'
#' @param keep The results to output: "increments" outputs a \code{data.frame}
#' with cumulative hourly developmental increments, while "stages" or
#' "generations" output a \code{data.frames} summarising the time point when
#' development commenced and completed. The default output is a list
#' of three \code{data.frames} with all outputs.
#
#'
#' @return \code{data.frame} or \code{list}.
#' @export
#'
#' @examples
#' library(dplyr)
#'
#' # Sample hourly temperatures at a given location
#' d1 <- daily(days = 200, start_date = "2023-09-01")
#' h1 <- hourly(d1)
#'
#' # See the life stages
#' dev_params() # developmental parameters for diamondback moth
#' row.names(dev_params()) # possible values for "start_stage"
#'
#' # Predict forward 2 generations from the "egg" stage
#' predict_dev(
#'   df = h1,
#'   start_date = "2023-09-02",
#'   start_stage = "egg",
#'   start_dev = 0.5,
#'   gens = 2,
#'   direction = "forward",
#'   keep = "stages"
#'   )
#'
#' # Predict back in time 1 generation from the 4th instar stage
#' predict_dev(
#'   df = h1,
#'   start_date = "2024-03-01",
#'   start_stage = "instar4",
#'   start_dev = 0.5,
#'   gens = 1,
#'   direction = "back",
#'   keep = "stages"
#'   )
#'
#' # A warning is thrown if you try to predict beyond the available
#' # temperature data
#' predict_dev(
#'   df = h1,
#'   start_date = "2024-03-01",
#'   start_stage = "instar1_2",
#'   start_dev = 0,
#'   gens = 5,
#'   direction = "forward",
#'   keep = "gens"
#'   )
#'
predict_dev <- function(
    df,
    FUN = briere2,
    params = dev_params(),
    start_date,      # YYYY-MM-DD
    start_hour  = 12, # hour in 24hr format
    start_stage,
    start_dev = NULL, # set to 0 if dir = fwd and 1 if direction = back
    gens = 1,
    direction = "forward",
    keep = NULL # output everything, increments, stages or gens
) {

  # catch typos
  direction[grepl("^b|B", direction)] <- "back"
  direction[grepl("^f|F", direction)] <- "forward"

  if (!direction %in% c("forward", "back")) {
    stop("Direction must be forward or back")
  }

  if (!is.null(keep)) {
    keep[grepl("^i|I", keep)] <- "increments"
    keep[grepl("^s|S", keep)] <- "stages"
    keep[grepl("^g|G", keep)] <- "generations"
    if (!keep %in% c("increments", "stages", "generations"))
      keep <- NULL # if mis-specified, keep all output
  }

  # check for mis-specified function arguments
  # if(!FUN == "briere2"){
  #   stop("The only valid FUN currently is briere2. Did you misspell it?")
  # }

  # check for valid stages
  if(!start_stage %in% row.names(dev_params())){

    stop(
      paste("start_stage must be one of: ",
            paste(row.names(dev_params()), collapse = ", "))
      )
  }

  check_date <- suppressWarnings(lubridate::as_date(start_date))
  if(is.na(check_date)){
    stop("start_date must be in YYYY-MM-DD format (character).")
  }

  # check there is a single location only
  # To do: we might not need location check (if we don't need a location_key)
  # If we remove, then just check for no duplicated datetimes in input
  if ("location_key" %in% names(df) && length(unique(df$location_key)) > 1) { # datetimes must be unique
    stop("Multiple location_keys detected in df. Provide data for a single location.")
  }

  if (anyDuplicated(df$datetime) > 0) { # datetimes must be unique
    stop("There are duplicated datetimes in df")
  }

  if (!start_stage %in% rownames(params)) {
    stop(
      "`start_stage` must be a life stage that exists in the `params` object"
    )
  }

  if (!is.null(start_dev) && (start_dev < 0 | start_dev > 1)) {
    stop("`start_dev` must be a value between 0 and 1")
  }

  if (!"datetime" %in% names(df) || !"obs" %in% names(df)) {
    stop("`df` must contain the variables `datetime` and `obs`")
  }

  if (!as.character(start_date) %in% as.character(lubridate::date(df$datetime))) {
    stop(
      paste("`start_date` is not present in the temperature data.\n",
            "This might be because the temperature data frame cannot be found, ",
            "or the start_date is not covered by the time series of data. ",
            "or the start_date is  not in the correct format (YYYY-MM-DD).")
    )
  }

  if (is.null(start_dev) && direction == "forward") {
    start_dev <- 0
  }

  if (is.null(start_dev) && direction == "back") {
    start_dev <- 1
  }

  startdt <- lubridate::ymd_hms(
    paste(start_date, start_hour, sep = "-"), truncated = 2
  )

  if (direction == "forward") {
    df <- df %>%
      dplyr::filter(datetime >= startdt) %>%
      dplyr::arrange(datetime)
    all_stages <- rownames(params)
  }

  if (direction == "back") { # invert df and stages
    df <- df %>%
      dplyr::filter(datetime <= startdt) %>%
      dplyr::arrange(desc(datetime))
    all_stages <- rev(rownames(params))
  }

  out_gens <- vector("list", gens)
  fitted <- c()

  # gen 1
  stages <- all_stages[which(all_stages == start_stage):length(all_stages)]
  out <- vector("list", length(stages))
  names(out) <- stages

  for (s in stages) {

    tmp_df <- dplyr::filter(df, !datetime %in% fitted)
    out[[s]] <- do.call(
      FUN, c(list(df = tmp_df),
             direction = direction,
             params[s, ])
    ) %>%
      dplyr::mutate(stage = s, gen = 1)

    if (s == start_stage) {

      if (direction == "forward") {
        out[[s]] <- out[[s]] %>%
          dplyr::filter(total_dev < (1 - start_dev)) %>%
          dplyr::mutate(total_dev = total_dev + start_dev)
      }

      if (direction == "back") {
        out[[s]] <- out[[s]] %>%
          dplyr::filter(total_dev > (1 - start_dev)) %>%
          dplyr::mutate(total_dev = total_dev - (1 - start_dev))
      }
    }

    fitted <- c(fitted, out[[s]]$datetime) %>%
      lubridate::as_datetime() # reverts conversion to numeric in gen 1
  }

  out_gens[[1]] <- bind_rows(out)

  # gens > 1
  if (gens >= 2) {

    out <- vector("list", length(all_stages))
    names(out) <- all_stages

    for (g in seq(gens)[-1]) {

      for (s in all_stages){

        tmp_df <- dplyr::filter(df, !datetime %in% fitted)
        out[[s]] <- do.call(
          FUN, c(list(df = tmp_df),
                 direction = direction,
                 params[s, ])
        ) %>%
          dplyr::mutate(stage = s, gen = g)

        fitted <- c(fitted, out[[s]]$datetime)
      }
      out_gens[[g]] <- bind_rows(out)
    }
  }

  # check that output is complete
  max_gen   <- max(which(sapply(out_gens, nrow) > 0))
  max_stage <- dplyr::last(out_gens[[max_gen]][, "stage"])
  max_dev   <- dplyr::last(out_gens[[max_gen]][, "total_dev"])

  msg1 <- "Output may be incomplete."
  msg2 <- "Predictions exceed time series of temperature data."
  msg3 <- paste0("Development is predicted to generation = ", max_gen,
                 ", life stage = ", max_stage,
                 ", and total development = ", round(max_dev, 4))

  # If there's a location_key in df, add this in error msg.
  # This is mainly for use with predict_development_locations
  if ("location_key" %in% names(df)){
    msg1 <- paste0(unique(df$location_key), ": ", msg1)
  }

  # truncate to remove any empty dfs to avoid later errors
  out_gens <- out_gens[1:max_gen]

  if (direction == "forward") {

    if (max_gen < gens || !max_stage == dplyr::last(all_stages) ||
        max_dev < 0.75) {

      message(paste(msg1, msg2, msg3))
    }
  }

  if (direction == "back") {

    if (max_gen < gens || !max_stage == dplyr::last(all_stages) ||
        max_dev > 0.25) {

      message(paste(msg1, msg2, msg3))
    }
  }

  count_days <- function(df){
    df %>%
      dplyr::mutate(d = 1 / 24,
                    total_days = cumsum(d), 3) %>%
      dplyr::select(-d)
  }

  out_all <- vector("list", 3)
  names(out_all) <- c("increments", "stages", "generations")

  out_all[[1]] <- out_gens %>%
    dplyr::bind_rows() %>%
    count_days() %>%
    dplyr::select(
      datetime, obs, gen, stage, dev, total_dev, total_days
    ) %>%
    as_tibble()

  summarise_stages <- function(df, direction) {

    res <- df %>%
      count_days %>%
      dplyr::group_by(gen, stage) %>%
      dplyr::summarise(
        start_dev = min(datetime),
        complete_dev = max(datetime),
        total_days = max(total_days) - min(total_days),
        mean_temp_oC = mean(obs), # oC may not be suitable for USA users!
        .groups = "drop"
      )

    if (direction == "back") {

      res %>%
        dplyr::arrange(desc(complete_dev)) %>%
        dplyr::select(gen, stage, complete_dev, dplyr::everything())

    } else {
      res
    }
  }

  out_all[[2]] <- out_gens %>%
    lapply(FUN = summarise_stages, direction = direction) %>%
    dplyr::bind_rows()

  summarise_gens <- function(df, direction) {

    res <- df %>%
      count_days %>%
      dplyr::group_by(gen) %>%
      dplyr::summarise(
        start = dplyr::first(stage),
        end =   dplyr::last(stage),
        start_dev = min(datetime),
        complete_dev = max(datetime),
        total_days = max(total_days) - min(total_days),
        mean_temp_oC = mean(obs, na.rm = TRUE),
        .groups = "drop"
      )

    if (direction == "back") {

      res %>%
        dplyr::mutate(stages = paste(start, end, sep = " to ")) %>%
        dplyr::arrange(desc(complete_dev)) %>%
        dplyr::select(-end, -start) %>%
        dplyr::select(gen, stages, complete_dev, dplyr::everything())

    } else if (direction == "forward") {

      res %>%
        dplyr::mutate(stages = paste(start, end, sep = " to ")) %>%
        dplyr::arrange(complete_dev) %>%
        dplyr::select(-end, -start) %>%
        dplyr::select(gen, stages, start_dev, dplyr::everything())

    }
  }
  out_all[[3]] <- out_gens %>%
    lapply(FUN = summarise_gens, direction = direction) %>%
    dplyr::bind_rows()

  if (is.null(keep)) {return (out_all)}

  if (keep == "increments")  {return(out_all$increments)}
  if (keep == "stages")      {return(out_all$stages)}
  if (keep == "generations") {return(out_all$generations)}

}

